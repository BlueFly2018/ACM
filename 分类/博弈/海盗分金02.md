# 海盗分金02

### 题目链接：http://codeforces.com/problemset/problem/690/A2

#### 题意&&思路：感谢大佬：https://blog.csdn.net/dpppbr/article/details/51893716

#### “海盗分金”问题，n个人分m个金币（金币是最小单位，不可再分割），首先第一个人提出分配方案，当半数，或半数以上的人同意时，分配完成，不然，杀死第一个人，让第二个人进行提出分配方案，直到人全死光（当然根据题意这是不可能的……）或者一个半数或半数以上的分配方案被提出。每个参与者都是所谓的“非常聪明”的，以及他们的行为遵循以下两个原则：

1. **自己要确保自己不可以死（当然有时候你不得不死23333）**
2. **满足第一个条件的情况下，获得更多的金币**

#### **现在你是第一个人，问你当参与者为n的时候，你至少需要多少金币可以保证自己不被杀死（你可以不给自己金币，并且支持自己的方案，以尽力保证自己不会被杀）。**

**思路：不妨先思考一下：（为了方便讨论，把最后一个人提出方案的人称为第1个人，第一个提出方案的人称为第n个人）**

**1	0**

**2	0**

**3	1**

**4	0**

**5	2**

**6	1**

**7	3**

**8	0**

**9	4**

**10	1**

**如果只有1个人，0个金币（只有自己一个人当然不用金币啦）。**

**如果只有2个人，0个金币（自己不要金币，自己支持自己的方案）。**

**如果只有3个人，1个金币（如果没有金币，考虑前文两个人的情况，第3个人不能给出比前文两个人更好的分配方案，第3个人只有死，那么第3个人需要一个金币来博取后两个人中一个人的支持）**

**如果只有4个人，0个金币！！！（没有金币，前文第3个人必死，只能支持第4个人，第4个人支持自己，ok）**

**5个人，2金币（前面的人没有必死的可能，所以没人支持他，他需要两个金币去贿赂两个人）**

**6个人，1金币（如果只有一个金币的话，6号死后5号必死（因为他需要两个金币），所以5号无条件支持6号，6号只需要用这个金币在贿赂一个人支持他就好了）**

**7个人，3金币（有三个金币的话，前面的的人没有人无条件支持他（因为前面的人最多只需要2个金币，有三个金币的话，前面的人自己干），所以他需要三个金币去贿赂三个人）**

**8个人，0金币（没有金币的话，5,6,7都是必死的所以他们会无条件支持8号）**

**9个人，4金币（同理7号，所以要四个金币）**

**10个人，1金币（有一个金币的话，7,9会无条件支持10号 注意8号：如果到8号的时候因为有一个金币所以6号不会支持8号（他会自己干）;所以5号更加不会支持（6号不会死，他也不会死），那么8号会缺两个人金币不够贿赂，那么他只能支持10号，；10号有7,8,9，支持，在有一金币贿赂一个人支持他就好了）**

**…………**

**有了这种思路就好办了，这时候你会发现题目给了一个提示，样例三，99个人49个金币，很容易想到当n为奇数时，答案为(n-1)/2。（啥？你问我怎么想到的？瞎猜啊……）如果前面一些答案自己推过，你会发现奇数总是处在一个很尴尬的地位，当他没有(n-1)/2个金币时，前面总有人可以提出满足这些金币的分配方案，那么作为第一个提出分配的人，无法提出更好的要求，只有死路一条。除非有(n-1)/2个金币，你可以把这些金币分配给在下一个提出偶数方案的人所提方案中没有得到金币的(n-1)/2个人，加上自己支持自己，你就可以活下来。**

**那么偶数个人的情况呢？再瞎猜一下（这什么题解啊喂，全是靠猜的=   =）：当人数为n的幂次时，0个金币就能活下来。这个的证明方法……数学归纳法吗？总之思路是因为n为2的幂次，[n/2+1,n-1]这些人由于拿不出更好的分配方案，会被[1,n/2]这些人投反对票，为了保命，[n/2+1,n-1]这(n/2-1)个人只能支持第n个人，加上第n个人自己支持自己，就ok了。**

**2的幂次被解决了，那么不是2的幂次的偶数呢？假如说你现在有10个人，1枚金币，由于第6个人有1个金币的分配方案，[7,9]这三个人无法提出更好的分配方案，只能支持第10个，第10个自己支持自己，恰好还有一枚金币收买一个人，ok。这样同理，第18个人也需要1个金币，[11,17]为了保命，是一定会支持第18个人的。也就是说，设m为最接近n且小于等于n的2的幂次，一个偶数需要的金币数是(n-m)/2。**

**以上。**



```c++
#include<iostream>
using namespace std;

int main()
{
	int n;
	while(cin>>n)
	{
	
		if(n&1)
		cout<<n/2<<endl;
		else
		{
			int m=2;
			while(m<=n)
			{
				m<<=1;
			}
			m>>=1;
			cout<<(n-m)/2<<endl;
			
			
		}
	}
}
```

